# Bunny's Big Adventure!
# Created by: Jenna Netland
# Copyright (c) 2012 All Rights Reserved, Jenna Netland
# All images and music are also Copyright (c) 2012 All Rights Reserved, Jenna Netland

# Good luck, and hope you enjoy :)


# Copyright (c) 2012 All Rights Reserved, Jenna Netland

import math
import random
import simplegui
import urllib2
import codeskulptor

def deserialize(string, splitters=[' ', ';', ',']):
    lst = []
    for sub_str in string.split(splitters[0]):
        if not sub_str:
            break
        elif sub_str[0] == 'T':
            lst.append(True)
        elif sub_str[0] == 'F':
            lst.append(False)
        elif sub_str[0] == 'N':
            lst.append(None)
        elif sub_str[0] == '[' and sub_str[-1] == ']':
            lst.append(deserialize(sub_str[1:-1], splitters[1:]))
        elif sub_str[0] == '"' and sub_str[-1] == '"':
            lst.append(sub_str[1:-1].replace('_', ' '))
        else:
            lst.append(float(sub_str))
    return lst

    
def _inside_rect(point, rect):
    if not ((rect[0][0] <= point[0] <= rect[1][0]) or (rect[0][0] >= point[0] >= rect[1][0])):
        return False
    if not ((rect[0][1] <= point[1] <= rect[1][1]) or (rect[0][1] >= point[1] >= rect[1][1])):
        return False
    return True

class Menu:
    def __init__(self, screen, buttons = []):
        self.buttons = buttons
        self.screen = screen
            
    def draw(self, canvas):
        canvas.draw_image(self.screen[0], self.screen[1], self.screen[2], self.screen[3], self.screen[4], self.screen[5])
        for b in self.buttons:
            b.draw(canvas)
                   
    def click(self, pos):
        for b in self.buttons:
            b.activate_if_in(pos)
                
class Image:
    def __init__(self, image, image_center, src_size, dest_size, dest_shift=[0,0], tile_skip=[0,0]):
        self.image = image
        self.image_center = image_center
        self.src_size = src_size
        self.dest_size = dest_size
        self.dest_shift = dest_shift
        self.tile_skip = tile_skip
        
    def draw(self, canvas, pos, tile=[0, 0], rot=0):
        canvas.draw_image(self.image, [self.image_center[0] + tile[0] * self.tile_skip[0], self.image_center[1] + tile[1] * self.tile_skip[1]], self.src_size, [pos[0] + self.dest_shift[0], pos[1] + self.dest_shift[1]], self.dest_size, rot)

      
class Button:
    def __init__(self, pos, image, image_center, image_size, action):
        self.pos = pos
        self.action = action
        d = [image_size[0] / 2, image_size[1] / 2]
        self._rect = [[pos[0] + d[0], pos[1] + d[1]], [pos[0] - d[0], pos[1] - d[1]]]
        self._image = Image(image, image_center, image_size, image_size)

    def draw(self, canvas):
        self._image.draw(canvas, self.pos)
        
    def activate_if_in(self, pos):
        if _inside_rect(pos, self._rect):
            self.action()


class Treat():
    def __init__(self, pos, image_center, image_size, image_radius, color, platforms, collected = False):
        self.platforms = platforms
        self.collected = collected
        self.color = color
        self.pos = pos
        self.radius = image_radius
        
        _img = simplegui.load_image(codeskulptor.file2url("assets-bunnyadventure-Object_Image_Carrots.png"))
        self.image = Image(_img, [image_center[0] + color * (image_size[0]+1), image_center[1]], image_size, [image_size[0] * 1.2, image_size[1] * 1.2])
        
    def get_color(self):
        return self.color
    
    def get_pos(self):
        return self.pos
    
    def get_radius(self):
        return self.radius
    
    def is_collected(self):
        return self.collected
    
    def collect(self):
        self.collected = True
        for p in self.platforms:
            p.activate()
                
    def drop(self):
        self.collected = False
        for p in self.platforms:
            p.deactivate()
                
    def draw(self, canvas, offset, visible = False):
        if not self.collected or visible:
            self.image.draw(canvas, [self.pos[0] + offset[0], self.pos[1] + offset[1]])

    
class Platform():
    def __init__(self, points, vel, image_center, image_size, interval, color, active = False, on = True):
        self.active = active
        self.on = on
        self.orig_state = [active, on]
        self.interval = interval
        self.time = 0
        self.vel = vel
        self.pos = [( points[0][0] + points[1][0])/2.0, ( points[0][1] + points[1][1])/2.0]
        self.d   = [(-points[0][0] + points[1][0])/2.0, (-points[0][1] + points[1][1])/2.0]

        image = simplegui.load_image(codeskulptor.file2url("assets-bunnyadventure-Object_Image_Platforms.png"))
        self._image_center = Image(image, [image_center[0] + color * image_size[0], image_center[1]], [image_size[0] - 12, image_size[1]], [2 * self.d[0], image_size[1]], [0, image_size[1] / 2.0], [0, image_size[1]])
        self._image_left   = Image(image, [3  + color * image_size[0], image_center[1]], [6, image_size[1]], [6, image_size[1]], [0, image_size[1] / 2.0], [image_size[0], image_size[1]])
        self._image_right  = Image(image, [image_size[0] - 3 + color * image_size[0], image_center[1]], [6, image_size[1]], [6, image_size[1]], [0, image_size[1]/2], [image_size[0], image_size[1]])
                
    def update(self):
        if self.active:
            self.time = (self.time + 1) % (2 * self.interval)
            self.pos[0] += self.vel[0] * (-1) ** (self.time // self.interval)
            self.pos[1] += self.vel[1] * (-1) ** (self.time // self.interval)
            
    def get_rect(self):
        return [[self.pos[0] - self.d[0], self.pos[1] - self.d[1]], [self.pos[0] + self.d[0], self.pos[1] + self.d[1]]]
    
    def draw(self, canvas, offset):
        t = 0 if self.on else 1
        self._image_center.draw(canvas, [self.pos[0] + offset[0], self.pos[1] + offset[1]], [0, t])
        self._image_left.draw(canvas, [self.pos[0] - self.d[0] + offset[0], self.pos[1] - self.d[1] + offset[1]], [0, t])
        self._image_right.draw(canvas, [self.pos[0] + self.d[0] + offset[0], self.pos[1] + self.d[1] + offset[1]], [0, t])
        
    def activate(self):
        self.active = True
        self.on = True
        
    def deactivate(self):
        self.active = self.orig_state[0]
        self.on = self.orig_state[1]
        
    def get_x_vel(self):
        return self.vel[0] * (-1) ** (self.time // self.interval)

    
class Sparkles():
    def __init__(self, rotation_speed = 0):
        self.rotation_speed = rotation_speed
        self.t = 0
        self.pos = [0, 0]
       
        _paths = [codeskulptor.file2url("assets-bunnyadventure-Menu_Image_" + color + "Sparkles.png") for color in ["", "Red", "Blue"]]
        self.sparkles = [(Image(simplegui.load_image(i), [34, 35], [70, 70], [105, 105], tile_skip=[70, 0])) for i in _paths]
        self.rots = [0.0, math.pi / 3.0, 2.0 * math.pi / 3.0]        
    
    def draw(self, canvas):
        for sparkle, _r in zip(self.sparkles, self.rots):
            sparkle.draw(canvas, self.pos, [(self.t // 3) % 7, 0], rot = self.t * self.rotation_speed + _r)
            sparkle.draw(canvas, self.pos, [(3 + self.t // 3) % 7, 0], rot = self.t * self.rotation_speed + .9 + _r)
        self.t = (self.t + 1) % 21000
            
    def set_pos(self, pos):
        self.pos = pos
    
    
class UnstableObject():
    def __init__(self, pos, vel, gravity, speed, jump_height, direction = 0, scale = 1):
        self.gravity = gravity
        self.speed = speed
        self.jump_height = jump_height
        self.direction = direction
        self.relative_vel = 0
        self.num_jumps = 0
        self.max_jumps = 2
        self.tile = [0, 0]
        self.pos = pos
        self.vel = vel
        self.radius = 21
        _image = simplegui.load_image(codeskulptor.file2url("assets-bunnyadventure-Object_Image_Bunnies.png"))
        self._image = Image(_image, [22, 26], [45, 52], [45, 52], tile_skip=[45, 52])
    
    def with_platform(self, platform):
        rect = platform.get_rect()
        rect[1][1]  = rect[0][1] - self.radius - self.vel[1] - 1
        if platform.on and self.vel[1] > 0 and _inside_rect(self.pos, rect):
            self.pos[1] = rect[0][1] - 1 - self.radius
            self.vel[1] = 0
            if platform.active:
                self.relative_vel = platform.get_x_vel()
            self.num_jumps = 0
        
    def get_pos(self):
        return self.pos        
    
    def move(self):
        self.vel[1] += self.gravity
        self.vel[0]  = self.direction * self.speed + self.relative_vel
        self.relative_vel = 0
        self.pos[0] += self.vel[0]
        self.pos[1] += self.vel[1]
    
    def jump(self):
        if self.num_jumps < self.max_jumps:
            self.vel[1] = -math.sqrt(math.fabs(2 * self.gravity * self.jump_height))
            self.num_jumps += 1

    def draw(self, canvas, offset, _cnt=[0]):
        self.tile[1] = [1, self.tile[1], 0][1 + self.direction]
        _cnt[0] = (_cnt[0] + 1) % 9            
        if self.num_jumps > 0:
            self.tile[0] = [1, 0, 2][(self.vel[1] > 0) - (self.vel[1] < 0) + 1]
        else:
            self.tile[0] = [0, (self.tile[0] + _cnt[0] // 8) % 3][self.direction != 0]        
        self._image.draw(canvas, [self.pos[0] + offset[0], self.pos[1] + offset[1]], self.tile)
        
        
class Animal(UnstableObject):
    def __init__(self, pos, vel,  gravity, speed, jump_height, controls, direction = 0, scale = 1, num_treats = 2):
        self.treats = [None, None]
        self.num_treats = num_treats
        # 0 = left, 1 = right, 2 = jump, 3 = throw
        self.controls = controls
        self.control_state = [False, False, False, False]
        UnstableObject.__init__(self, pos, vel,   gravity, speed, jump_height, direction, scale)
    
    def with_carrot(self, carrot):
        d = math.sqrt((self.pos[0] - carrot.get_pos()[0]) ** 2 + (self.pos[1] - carrot.get_pos()[1]) ** 2)
        if d > self.radius + carrot.get_radius() or carrot.is_collected():
            return
        if self.treats[0] != None:
            self.treats[0].drop()
        self.treats = [self.treats[1], carrot]
        carrot.collect()
     
    def drop_treat(self):
        popped = False
        for i in range(self.num_treats):
            if self.treats[i] != None and not popped:
                self.treats[i].drop()
                self.treats.pop(i)
                self.treats.insert(i, None)
                popped = True
    
    def key_handler(self, key, sign):
        for i in range(0, 4):
            if key == simplegui.KEY_MAP[self.controls[i]]:
                if sign == 'down':
                    self.control_state[i] = True
                    self.update_direction()
                elif sign == 'up':
                    self.control_state[i] = False
                    self.update_direction()
                else:
                    print(sign)
                    print("Error: Animal.key_handler(): incorrect sign")
                    
    def update_direction(self):
        if self.control_state[0] and not self.control_state[1]:
            self.direction = -1
        elif not self.control_state[0] and self.control_state[1]:
            self.direction = 1
        else:
            self.direction = 0
        if self.control_state[2]:
            self.jump()
            self.control_state[2] = False
        if self.control_state[3]:
            self.drop_treat()
            self.control_state[3] = False
            
    # Accessor Methods
    def get_treats(self):
        return self.treats
    
    def clear_treats(self):
        for i in range(0, len(self.treats)):
            self.drop_treat() 
            
    def get_num_treats(self):
        return self.num_treats
    
    def set_num_treats(self, n):
        self.num_treats = n
        self.clear_treats()
  

import codeskulptor


# -----------------------
# Images and Sound
# -----------------------

# Images
button_image = simplegui.load_image(codeskulptor.file2url("assets-bunnyadventure-Menu_Image_Buttons.png"))

easy_screen_image = simplegui.load_image(codeskulptor.file2url("assets-bunnyadventure-Game_Screen_Easy.png"))
medium_screen_image = simplegui.load_image(codeskulptor.file2url("assets-bunnyadventure-Game_Screen_Medium.png"))
hard_screen_image = simplegui.load_image(codeskulptor.file2url("assets-bunnyadventure-Game_Screen_Hard.png"))

paused_screen_image = simplegui.load_image(codeskulptor.file2url("assets-bunnyadventure-Game_Screen_Pause.png"))
level_screen_image = simplegui.load_image(codeskulptor.file2url("assets-bunnyadventure-Menu_Screen_LevelWin.png"))
final_screen_image = simplegui.load_image(codeskulptor.file2url("assets-bunnyadventure-Menu_Screen_AllWin.png"))

# -----------------------
# Class Definitions
# -----------------------
       
    

class Game:
    def __init__(self, level):
        
        self.easy_screen = [easy_screen_image, [450, 300], [900, 600], [450, 300], [900, 600], 0]
        self.medium_screen = [medium_screen_image, [450, 300], [900, 600], [450, 300], [900, 600], 0]
        self.hard_screen = [hard_screen_image, [450, 300], [900, 600], [450, 300], [900, 600], 0]

        resume_button = Button([300, 350], button_image, [3875, 50], [251, 100], lambda : self.unpause())
        self.pause_menu = Menu([paused_screen_image, [450, 300], [900, 600], [450, 300], [900, 600], 0], [resume_button])
            
        self.animal = None
        self.controls = ['left', 'right', 'up', 'space']

        self.sparkles = Sparkles(.05)
        
        self.camera_offset = [0, 0]
        self.levels = []
        self.next_level_timer = simplegui.create_timer(1000, self.level_end)
        
        self.level = level
        self.treats = []
        self.platforms = []
        self.text = None
        self.screen = None
        
        self.in_level = False
        self.is_ending = False
        self.paused = False
        self.start_game()
    
    def create_levels(self):
        self.levels = []
        a_file = urllib2.urlopen('https://raw.githubusercontent.com/fbeilstein/machine_learning/master/test.txt')
        data = a_file.read().split('L')
        for level in data:
            if len(level) > 2:
                self.levels.append(level)
        
    def start_game(self):
        self.create_levels()
        self.get_level()
    
    def update(self):
        self.animal.move()
        
        for p in self.platforms:
            self.animal.with_platform(p)
            p.update()
        for t in self.treats:
            self.animal.with_carrot(t)
            
        p = self.animal.get_pos()
        self.camera_offset = [450 - p[0], 300 - p[1]]
        if p[1] > 999:	# condition to lose level
            self.get_level()

    
    def draw(self, canvas):
        
        # Scene
        canvas.draw_image(self.screen[0], self.screen[1], self.screen[2], self.screen[3], self.screen[4], self.screen[5])
        if self.text[0] != None:
            canvas.draw_text(self.text[0], [self.text[1][0] + self.camera_offset[0], self.text[1][1] + self.camera_offset[1]], self.text[2], self.text[3])
        
        # Objects
        self.animal.draw(canvas, self.camera_offset)
        for p in self.platforms:
            p.draw(canvas, self.camera_offset)
        for t in self.treats:
            t.draw(canvas, self.camera_offset)

        # Current Treats Box
        canvas.draw_polygon([(25, 30), (100, 30), (100, 70), (25, 70)], 5, "White")
        t = self.animal.get_treats()
        for i in range(len(t)):
            if t[i] != None:
                if t[i].get_color() == 0 and self.in_level:
                    self.in_level = False
                    self.is_ending = True
                    self.next_level_timer.start()
                    self.sparkles.set_pos([t[i].get_pos()[0] + self.camera_offset[0], t[i].get_pos()[1] + self.camera_offset[1]])
                else:
                    t[i].draw(canvas, [44 + 35 * i - t[i].get_pos()[0], 50 - t[i].get_pos()[1]], True)
                    
        # Display
        canvas.draw_text("Level: " + str(self.level), [110, 70], 40, "White")
        
        # Sparkles
        if self.is_ending:
            self.sparkles.draw(canvas)
    
    def keyup_handler(self, key):
        if self.in_level and not self.paused:
            self.animal.key_handler(key, 'up')
        
    def unpause(self):
        self.paused = False
        
    def level_end(self):
        pass
    
    def next_level(self):
        if self.level < len(self.levels) - 1:
            self.level += 1
            self.get_level()
    
    def get_level(self):
        self.animal    = Animal([450, 300], [0,0], .5, 3, 120, self.controls, 0, 1, 2)
        self.treats    = []
        self.platforms = []
        self.in_level  = True
        level_str = self.levels[self.level]
        for objs in level_str.split('\n'):
            if len(objs) < 1:
                pass
            elif objs[0] == 'P':
                params = deserialize(objs[2:])
                self.platforms.append(Platform(params[0], params[1], params[2], params[3], params[4], params[5], params[6], params[7]))
                #print "Platform: ", params
            elif objs[0] == 'C':
                params = deserialize(objs[2:])
                p = [self.platforms[int(idx)] for idx in params[5]]
                self.treats.append(Treat(params[0], params[1], params[2], params[3], params[4], p))
                #print "Treat: ", params
            elif objs[0] == 'T':
                self.text = deserialize(objs[2:])
                #print "Text: ", self.text
        
        if self.level <= 10:
            self.screen = self.easy_screen
        elif self.level <= 20:
            self.screen = self.medium_screen
        else:
            self.screen = self.hard_screen

        
     
class PuzzleGame(Game):
    def __init__(self, level):
        Game.__init__(self, level)
        next_button = Button([625, 350], button_image, [625, 50], [251, 100], self.next_level)
        replay_button = Button([275, 350], button_image, [375, 50], [251, 100], self.replay_level)
        self.level_menu = Menu([level_screen_image, [450, 300], [900, 600], [450, 300], [900, 600], 0], [replay_button, next_button])
        self.final_menu = Menu([final_screen_image, [450, 300], [900, 600], [450, 300], [900, 600], 0], [replay_button])
        
    def main(self, canvas):
        if self.paused:
            self.pause_menu.draw(canvas)
        elif self.in_level:
            self.update()
            self.draw(canvas)
        elif self.is_ending:
            self.draw(canvas)
        elif self.level == len(self.levels) - 1:
            self.final_menu.draw(canvas)
        else:
            self.level_menu.draw(canvas)
        
    def keydown_handler(self, key):
        if key == simplegui.KEY_MAP['p']:
            self.paused = not self.paused
        elif self.paused:
            pass
        elif self.in_level:
            self.animal.key_handler(key, 'down')
        elif self.level == len(self.levels) - 1:
            self.final_menu.keyhandler(key)
        else:
            pass
        
    def click(self, pos):
        if self.paused:
            self.pause_menu.click(pos)
        elif self.in_level:
            pass
        elif self.level == len(self.levels) - 1:
            self.final_menu.click(pos)
        else:
            self.level_menu.click(pos)
        
    def replay_level(self):
        self.get_level()
        
    def level_end(self):
        self.next_level_timer.stop()
        self.is_ending = False
        
# -----------------------
# Starting Game and Frame
# -----------------------
    
width = 900
height = 600

frame = simplegui.create_frame("Bunny's Big Adventure!", width, height, 100)

_puzzle_game = PuzzleGame(1) # initial level

frame.set_draw_handler(_puzzle_game.main)
frame.set_keydown_handler(_puzzle_game.keydown_handler)
frame.set_keyup_handler(_puzzle_game.keyup_handler)
frame.set_mouseclick_handler(_puzzle_game.click)

frame.set_canvas_background("Green")
frame.start()
